---
title: "Missing-Surrogate-Sims"
author: "Anh + Sarah"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 8, fig.height = 10, cache = TRUE)
library(ggplot2) ## for pretty plots 
library(latex2exp) ## for LaTex in pretty plots
source("~/Wake Forest University Dropbox/Sarah Lotspeich/8 - TRAINEE RESEARCH/Anh-Missing-Surrogates/R.s.miss.R")
```

## Assumptions 

  1.  The true proportion of treatment effect explained by the surrogate is $R = 0.5$. 
  2.  The data are generated under a parametric model. 

```{r}
########################################
### Functions to generate data ######
########################################
gen.data = function(setting, n1, n0) {
	s1 = g.1(n1)
	y1 = f.cond.1(s1)
	s0 = g.0(n0)
	y0 = f.cond.0(s0)
	return(data.frame("s1" = s1, "y1" = y1, "s0" = s0, "y0" = y0))
}
f.cond.1 = function(s.vector) {
	eps1 = rnorm(length(s.vector),0,3)
	y1 = 2+5*s.vector+1 + 1*s.vector + eps1
	return(y1)		
}
f.cond.0 = function(s.vector) {
	eps0 = rnorm(length(s.vector),0,3)
	y0 = 2+5*s.vector+ eps0
	return(y0)		
}
g.1 = function(n, alpha0=5) { return(rnorm(n, alpha0 + 1,2))}
g.0 = function(n,alpha0=5) { return(rnorm(n, alpha0,1))}
```

## Simulations 
### Under MCAR 

Additional assumptions made at this stage: 

  3.  Sample sizes of $n_1 = 1000$ in the untreated group and $n_0 = 1000$ in the treated group. 
  4.  Some patients are missing data on the surrogate $S$ **completely at random**. 

#### One Iteration

```{r 1 sim MCAR}
# Be reproducible queens 
set.seed(1)

# Set sample sizes 
n1 = 1000
n0 = 1000

# Generate data 
data = gen.data(n1 = n1, n0 = n0) 

# Define vectors for outcomes/surrogates in untreated/treated 
s1 = data$s1
y1 = data$y1
s0 = data$s0
y0 = data$y0

##########################################################
#Estimates with complete data ############################
##########################################################
## Estimate R with nonparametric approach (gold standard)
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "robust")

## Estimate R with parametric approach (gold standard) ###
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "model")

# Simulate non-missingness indicators ###################
## Under MCAR, everybody has 30% missingness probability
m1 = rbinom(n1, 1, 0.70) 
m0 = rbinom(n0, 1, 0.70)
s0[m0==0] = NA ### make them missing
s1[m1==0] = NA ### make them missing

## Summarize amount of missingness
1 - mean(c(m0, m1)) ### total (both treatment groups)
1 - mean(m1) ### treatment group
1 - mean(m0) ### control group

##########################################################
#Estimates with incomplete data ##########################
##########################################################
## Estimate R with nonparametric approach (complete case)
Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                         szero = s0[m0==1], 
                         yone = y1[m1==1], 
                         yzero = y0[m0==1], 
                         type = "robust")

## Calculate weights for IPW approaches
ipw_dat = data.frame(m = c(m1, m0), 
                     y = c(y1, y0), 
                     z = rep(x = c(1, 0), each = 1000))
ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
w1 = predict(object = ipw_fit, 
               newdata = data.frame(m = m1, 
                                    y = y1, 
                                    z = 1),
               type = "response") 
w0 = predict(object = ipw_fit, 
               newdata = data.frame(m = m0, 
                                    y = y0, 
                                    z = 0),
               type = "response") 

## Estimate R with nonparametric approach (IPW)
Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                              szero = s0, 
                              yone = y1, 
                              yzero = y0, 
                              type = "robust", 
                              ipw = TRUE, 
                              wone = w1, 
                              wzero = w0)
print(Rnonparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_ipw = R.s.miss(sone = s1, 
                           szero = s0, 
                           yone = y1, 
                           yzero = y0, 
                           type = "model", 
                           ipw = TRUE, 
                           wone = w1, 
                           wzero = w0)
print(Rparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_smle = R.s.miss(sone = s1, 
                            szero = s0,
                            yone = y1,
                            yzero = y0, 
                            type = "model", 
                            ipw = FALSE) 
print(Rparam_miss_smle)
```

#### 1000 Iterations 

```{r 1000 sims MCAR}
# Be reproducible queens 
set.seed(1)

sim_res = data.frame(r = 1:1000, 
                     gs_nonparam_delta = NA, gs_nonparam_delta.s = NA, gs_nonparam_R.s = NA, 
                     gs_param_delta = NA, gs_param_delta.s = NA, gs_param_R.s = NA, 
                     cc_nonparam_delta = NA, cc_nonparam_delta.s = NA, cc_nonparam_R.s = NA, 
                     cc_param_delta = NA, cc_param_delta.s = NA, cc_param_R.s = NA, 
                     ipw_nonparam_delta = NA, ipw_nonparam_delta.s = NA, ipw_nonparam_R.s = NA, 
                     ipw_param_delta = NA, ipw_param_delta.s = NA, ipw_param_R.s = NA, 
                     smle_param_delta = NA, smle_param_delta.s = NA, smle_param_R.s = NA)
for (r in 1:1000) {
  # Generate data 
  data = gen.data(n1=n1, n0=n0) 
  
  # Define vectors for outcomes/surrogates in untreated/treated 
  s1 = data$s1
  y1 = data$y1
  s0 = data$s0
  y0 = data$y0

  ##########################################################
  #Estimates with complete data ############################
  ##########################################################
  ## Estimate R with nonparametric approach (gold standard)
  Rnonparam = Rsurrogate::R.s.estimate(sone=s1, 
                                       szero=s0, 
                                       yone = y1, 
                                       yzero = y0, 
                                       type = "robust")
  sim_res[r, c("gs_nonparam_delta", "gs_nonparam_delta.s", "gs_nonparam_R.s")] = with(Rnonparam, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (gold standard) ###
  Rparam = Rsurrogate::R.s.estimate(sone=s1, 
                                    szero=s0, 
                                    yone = y1, 
                                    yzero = y0, 
                                    type = "model")
  sim_res[r, c("gs_param_delta", "gs_param_delta.s", "gs_param_R.s")] = with(Rparam, 
                                                                             c(delta, delta.s, R.s))
  
  # Simulate non-missingness indicators ###################
  ## Under MCAR, everybody has 30% missingness probability
  m1 = rbinom(n1, 1, 0.70) 
  m0 = rbinom(n0, 1, 0.70)
  s0[m0==0] = NA ### make them missing
  s1[m1==0] = NA ### make them missing

  ##########################################################
  #Estimates with incomplete data ##########################
  ##########################################################
  ## Estimate R with nonparametric approach (complete case)
  Rnonparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                            szero = s0[m0==1], 
                                            yone = y1[m1==1], 
                                            yzero = y0[m0==1], 
                                            type = "robust")
  sim_res[r, c("cc_nonparam_delta", "cc_nonparam_delta.s", "cc_nonparam_R.s")] = with(Rnonparam_miss, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (complete case)
  Rparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                         szero = s0[m0==1], 
                                         yone = y1[m1==1], 
                                         yzero = y0[m0==1], 
                                         type = "model")
  sim_res[r, c("cc_param_delta", "cc_param_delta.s", "cc_param_R.s")] = with(Rparam_miss, 
                                                                             c(delta, delta.s, R.s))
  
  ## Calculate weights for IPW approaches
  ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
  w1 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m1, 
                                      y = y1, 
                                      z = 1),
                 type = "response")
  w0 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m0, 
                                      y = y0, 
                                      z = 0),
                 type = "response")
  
  ## Estimate R with nonparametric approach (IPW)
  Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                                szero = s0, 
                                yone = y1, 
                                yzero = y0, 
                                type = "robust", 
                                ipw = TRUE, 
                                wone = w1, 
                                wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rnonparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (IPW)
  Rparam_miss_ipw = R.s.miss(sone = s1, 
                             szero = s0, 
                             yone = y1, 
                             yzero = y0, 
                             type = "model", 
                             ipw = TRUE, 
                             wone = w1, 
                             wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with semiparametric approach (SMLE)
  Rparam_miss_smle = R.s.miss(sone = s1, 
                              szero = s0,
                              yone = y1,
                              yzero = y0, 
                              type = "model", 
                              ipw = FALSE) 
  sim_res[r, c("smle_param_delta", "smle_param_delta.s", "smle_param_R.s")] = with(Rparam_miss_smle, c(delta, delta.s, R.s))
  
  ## Save 
  sim_res |> 
    write.csv("~/Dropbox (Wake Forest University)/8 - TRAINEE RESEARCH/Anh-Missing-Surrogates/mcar_sim_res.csv", 
              row.names = FALSE)
}
```

#### Results

```{r, echo = FALSE, fig.width = 8, fig.height = 4, cache = FALSE}
# Make them long 
res_long = sim_res |> 
  tidyr::pivot_longer(cols = gs_nonparam_delta:smle_param_R.s, 
                      names_to = "method_quantity", values_to = "est") |> 
  dplyr::mutate(quantity = sub(pattern = ".*_", 
                               replacement = "", 
                               x = method_quantity), 
                truth = dplyr::case_when(
                  quantity == "delta" ~ 12, 
                  quantity == "delta.s" ~ 6, 
                  .default = 0.5), 
                quantity = factor(x = quantity, 
                                  levels = c("delta", "delta.s", "R.s"), 
                                  labels = c(TeX("$\\Delta$"), TeX("$\\Delta_S$"), TeX("$R_S$"))),
                method = sub(pattern = "_delta", 
                             replacement = "", 
                             x = sub(pattern = "_delta.s", 
                                     replacement = "", 
                                     x = sub(pattern = "_R.s", 
                                             replacement = "", 
                                             x = method_quantity)))) |> 
  dplyr::select(-method_quantity) |> 
  dplyr::mutate(method = factor(x = method, 
                                levels = c("gs_nonparam", "gs_param", 
                                           "cc_nonparam", "cc_param", 
                                           "ipw_nonparam", "ipw_param", 
                                           "smle_param"), 
                                labels = c("GS (NP)", "GS (P)", 
                                           "CC (NP)", "CC (P)", 
                                           "IPW (NP)", "IPW (P)",
                                           "SMLE (P)")), 
                parametric = !grepl(pattern = "(NP)", 
                                   x = method))

# Make a boxplot 
res_long |> 
  ggplot(aes(x = method, y = est, fill = parametric)) + 
  geom_boxplot() + 
  geom_hline(aes(yintercept = truth), linetype = 2, color = "white") + 
  facet_wrap(~quantity, scales = "free", ncol = 3, labeller = label_parsed) + 
  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 5)) + 
  theme_minimal() + 
  theme(legend.position = "top", 
        strip.background = element_rect(fill = "black"), 
        strip.text = element_text(color = "white")) + 
  ggtitle(label = "Boxplot of estimates under missingness completely at random (MCAR)")
```

### Under MAR Version 1 (Missingness Depends on Continuous Y)

Alternative assumptions made at this stage: 

  4.  Some patients are missing data on the surrogate $S$ **at random**. Specifically, the probability of a patient's surrogate being missing depends on their primary outcome $Y$ (continuously, in a logistic regression model). 

#### One Iteration

```{r 1 sim MAR cont Y}
# Be reproducible queens 
set.seed(1)

# Set sample sizes 
n1 = 1000
n0 = 1000

# Generate data 
data = gen.data(n1 = n1, n0 = n0) 

# Define vectors for outcomes/surrogates in untreated/treated 
s1 = data$s1
y1 = data$y1
s0 = data$s0
y0 = data$y0

##########################################################
#Estimates with complete data ############################
##########################################################
## Estimate R with nonparametric approach (gold standard)
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "robust")

## Estimate R with parametric approach (gold standard) ###
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "model")

# Simulate non-missingness indicators ###################
## Under MAR, probability of missingness depends on Y continuously (logistic regression)
m1 = rbinom(n = n1, size = 1, prob = 1 / (1 + exp(- 0.1 * y1)))
m0 = rbinom(n = n0, size = 1, prob = 1 / (1 + exp(- 0.1 * y0)))
s0[m0==0] = NA ### make them missing
s1[m1==0] = NA ### make them missing

## Summarize amount of missingness
1 - mean(c(m0, m1)) ### total (both treatment groups)
1 - mean(m1) ### treatment group
1 - mean(m0) ### control group

##########################################################
#Estimates with incomplete data ##########################
##########################################################
## Estimate R with nonparametric approach (complete case)
Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                         szero = s0[m0==1], 
                         yone = y1[m1==1], 
                         yzero = y0[m0==1], 
                         type = "robust")

## Calculate weights for IPW approaches
ipw_dat = data.frame(m = c(m1, m0), 
                     y = c(y1, y0), 
                     z = rep(x = c(1, 0), each = 1000))
ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
w1 = predict(object = ipw_fit, 
               newdata = data.frame(m = m1, 
                                    y = y1, 
                                    z = 1),
               type = "response") 
w0 = predict(object = ipw_fit, 
               newdata = data.frame(m = m0, 
                                    y = y0, 
                                    z = 0),
               type = "response") 

## Estimate R with nonparametric approach (IPW)
Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                              szero = s0, 
                              yone = y1, 
                              yzero = y0, 
                              type = "robust", 
                              ipw = TRUE, 
                              wone = w1, 
                              wzero = w0)
print(Rnonparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_ipw = R.s.miss(sone = s1, 
                           szero = s0, 
                           yone = y1, 
                           yzero = y0, 
                           type = "model", 
                           ipw = TRUE, 
                           wone = w1, 
                           wzero = w0)
print(Rparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_smle = R.s.miss(sone = s1, 
                            szero = s0,
                            yone = y1,
                            yzero = y0, 
                            type = "model", 
                            ipw = FALSE) 
print(Rparam_miss_smle)
```

#### 1000 Iterations 

```{r 1000 sims MAR cont Y}
# Be reproducible queens 
set.seed(1)

sim_res = data.frame(r = 1:1000, 
                     gs_nonparam_delta = NA, gs_nonparam_delta.s = NA, gs_nonparam_R.s = NA, 
                     gs_param_delta = NA, gs_param_delta.s = NA, gs_param_R.s = NA, 
                     cc_nonparam_delta = NA, cc_nonparam_delta.s = NA, cc_nonparam_R.s = NA, 
                     cc_param_delta = NA, cc_param_delta.s = NA, cc_param_R.s = NA, 
                     ipw_nonparam_delta = NA, ipw_nonparam_delta.s = NA, ipw_nonparam_R.s = NA, 
                     ipw_param_delta = NA, ipw_param_delta.s = NA, ipw_param_R.s = NA, 
                     smle_param_delta = NA, smle_param_delta.s = NA, smle_param_R.s = NA)
for (r in 1:1000) {
  # Generate data 
  data = gen.data(n1=n1, n0=n0) 
  
  # Define vectors for outcomes/surrogates in untreated/treated 
  s1 = data$s1
  y1 = data$y1
  s0 = data$s0
  y0 = data$y0

  ##########################################################
  #Estimates with complete data ############################
  ##########################################################
  ## Estimate R with nonparametric approach (gold standard)
  Rnonparam = Rsurrogate::R.s.estimate(sone=s1, 
                                       szero=s0, 
                                       yone = y1, 
                                       yzero = y0, 
                                       type = "robust")
  sim_res[r, c("gs_nonparam_delta", "gs_nonparam_delta.s", "gs_nonparam_R.s")] = with(Rnonparam, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (gold standard) ###
  Rparam = Rsurrogate::R.s.estimate(sone=s1, 
                                    szero=s0, 
                                    yone = y1, 
                                    yzero = y0, 
                                    type = "model")
  sim_res[r, c("gs_param_delta", "gs_param_delta.s", "gs_param_R.s")] = with(Rparam, 
                                                                             c(delta, delta.s, R.s))
  
  # Simulate non-missingness indicators ###################
  ## Under MAR, probability of missingness depends on Y continuously (logistic regression)
  m1 = rbinom(n = n1, size = 1, prob = 1 / (1 + exp(- 0.1 * y1)))
  m0 = rbinom(n = n0, size = 1, prob = 1 / (1 + exp(- 0.1 * y0)))
  s0[m0==0] = NA ### make them missing
  s1[m1==0] = NA ### make them missing

  ##########################################################
  #Estimates with incomplete data ##########################
  ##########################################################
  ## Estimate R with nonparametric approach (complete case)
  Rnonparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                            szero = s0[m0==1], 
                                            yone = y1[m1==1], 
                                            yzero = y0[m0==1], 
                                            type = "robust")
  sim_res[r, c("cc_nonparam_delta", "cc_nonparam_delta.s", "cc_nonparam_R.s")] = with(Rnonparam_miss, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (complete case)
  Rparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                         szero = s0[m0==1], 
                                         yone = y1[m1==1], 
                                         yzero = y0[m0==1], 
                                         type = "model")
  sim_res[r, c("cc_param_delta", "cc_param_delta.s", "cc_param_R.s")] = with(Rparam_miss, 
                                                                             c(delta, delta.s, R.s))
  
  ## Calculate weights for IPW approaches
  ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
  w1 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m1, 
                                      y = y1, 
                                      z = 1),
                 type = "response")
  w0 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m0, 
                                      y = y0, 
                                      z = 0),
                 type = "response")
  
  ## Estimate R with nonparametric approach (IPW)
  Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                                szero = s0, 
                                yone = y1, 
                                yzero = y0, 
                                type = "robust", 
                                ipw = TRUE, 
                                wone = w1, 
                                wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rnonparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (IPW)
  Rparam_miss_ipw = R.s.miss(sone = s1, 
                             szero = s0, 
                             yone = y1, 
                             yzero = y0, 
                             type = "model", 
                             ipw = TRUE, 
                             wone = w1, 
                             wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with semiparametric approach (SMLE)
  Rparam_miss_smle = R.s.miss(sone = s1, 
                              szero = s0,
                              yone = y1,
                              yzero = y0, 
                              type = "model", 
                              ipw = FALSE) 
  sim_res[r, c("smle_param_delta", "smle_param_delta.s", "smle_param_R.s")] = with(Rparam_miss_smle, c(delta, delta.s, R.s))
  
  ## Save 
  sim_res |> 
    write.csv("~/Dropbox (Wake Forest University)/8 - TRAINEE RESEARCH/Anh-Missing-Surrogates/mar_contY_sim_res.csv", 
              row.names = FALSE)
}
```

#### Results

```{r, echo = FALSE, fig.width = 8, fig.height = 4, cache = FALSE}
# Make them long 
res_long = sim_res |> 
  tidyr::pivot_longer(cols = gs_nonparam_delta:smle_param_R.s, 
                      names_to = "method_quantity", values_to = "est") |> 
  dplyr::mutate(quantity = sub(pattern = ".*_", 
                               replacement = "", 
                               x = method_quantity), 
                truth = dplyr::case_when(
                  quantity == "delta" ~ 12, 
                  quantity == "delta.s" ~ 6, 
                  .default = 0.5), 
                quantity = factor(x = quantity, 
                                  levels = c("delta", "delta.s", "R.s"), 
                                  labels = c(TeX("$\\Delta$"), TeX("$\\Delta_S$"), TeX("$R_S$"))),
                method = sub(pattern = "_delta", 
                             replacement = "", 
                             x = sub(pattern = "_delta.s", 
                                     replacement = "", 
                                     x = sub(pattern = "_R.s", 
                                             replacement = "", 
                                             x = method_quantity)))) |> 
  dplyr::select(-method_quantity) |> 
  dplyr::mutate(method = factor(x = method, 
                                levels = c("gs_nonparam", "gs_param", 
                                           "cc_nonparam", "cc_param", 
                                           "ipw_nonparam", "ipw_param", 
                                           "smle_param"), 
                                labels = c("GS (NP)", "GS (P)", 
                                           "CC (NP)", "CC (P)", 
                                           "IPW (NP)", "IPW (P)", 
                                           "SMLE (P)")), 
                parametric = !grepl(pattern = "(NP)", 
                                   x = method))

# Make a boxplot 
res_long |> 
  ggplot(aes(x = method, y = est, fill = parametric)) + 
  geom_boxplot() + 
  geom_hline(aes(yintercept = truth), linetype = 2, color = "white") + 
  facet_wrap(~quantity, scales = "free", ncol = 3, labeller = label_parsed) + 
  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 5)) + 
  theme_minimal() + 
  theme(legend.position = "top", 
        strip.background = element_rect(fill = "black"), 
        strip.text = element_text(color = "white")) + 
  ggtitle(label = "Boxplot of estimates under missingness at random (MAR)")
```

### Under MAR Version 2 (Missingness Depends on Binary Z)

Alternative assumptions made at this stage: 

  4.  Some patients are missing data on the surrogate $S$ **at random**. Specifically, the probability of a patient's surrogate being missing depends on their treatment assignment $Z$ (in a logistic regression model). 

#### One Iteration

```{r 1 sim MAR Z}
# Be reproducible queens 
set.seed(1)

# Set sample sizes 
n1 = 1000
n0 = 1000

# Generate data 
data = gen.data(n1 = n1, n0 = n0) 

# Define vectors for outcomes/surrogates in untreated/treated 
s1 = data$s1
y1 = data$y1
s0 = data$s0
y0 = data$y0

##########################################################
#Estimates with complete data ############################
##########################################################
## Estimate R with nonparametric approach (gold standard)
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "robust")

## Estimate R with parametric approach (gold standard) ###
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "model")

# Simulate non-missingness indicators ###################
## Under MAR, probability of missingness depends on Z (logistic regression)
m1 = rbinom(n = n1, size = 1, prob = 1 / (1 + exp(- 0.75)))
m0 = rbinom(n = n0, size = 1, prob = 1 / (1 + exp(- 0.10)))
s0[m0==0] = NA ### make them missing
s1[m1==0] = NA ### make them missing

## Summarize amount of missingness
1 - mean(c(m0, m1)) ### total (both treatment groups)
1 - mean(m1) ### treatment group
1 - mean(m0) ### control group

##########################################################
#Estimates with incomplete data ##########################
##########################################################
## Estimate R with nonparametric approach (complete case)
Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                         szero = s0[m0==1], 
                         yone = y1[m1==1], 
                         yzero = y0[m0==1], 
                         type = "robust")

## Calculate weights for IPW approaches
ipw_dat = data.frame(m = c(m1, m0), 
                     y = c(y1, y0), 
                     z = rep(x = c(1, 0), each = 1000))
ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
w1 = predict(object = ipw_fit, 
               newdata = data.frame(m = m1, 
                                    y = y1, 
                                    z = 1),
               type = "response") 
w0 = predict(object = ipw_fit, 
               newdata = data.frame(m = m0, 
                                    y = y0, 
                                    z = 0),
               type = "response") 

## Estimate R with nonparametric approach (IPW)
Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                              szero = s0, 
                              yone = y1, 
                              yzero = y0, 
                              type = "robust", 
                              ipw = TRUE, 
                              wone = w1, 
                              wzero = w0)
print(Rnonparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_ipw = R.s.miss(sone = s1, 
                           szero = s0, 
                           yone = y1, 
                           yzero = y0, 
                           type = "model", 
                           ipw = TRUE, 
                           wone = w1, 
                           wzero = w0)
print(Rparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_smle = R.s.miss(sone = s1, 
                            szero = s0,
                            yone = y1,
                            yzero = y0, 
                            type = "model", 
                            ipw = FALSE) 
print(Rparam_miss_smle)
```

#### 1000 Iterations 

```{r 1000 sims MAR Z}
# Be reproducible queens 
set.seed(1)

sim_res = data.frame(r = 1:1000, 
                     gs_nonparam_delta = NA, gs_nonparam_delta.s = NA, gs_nonparam_R.s = NA, 
                     gs_param_delta = NA, gs_param_delta.s = NA, gs_param_R.s = NA, 
                     cc_nonparam_delta = NA, cc_nonparam_delta.s = NA, cc_nonparam_R.s = NA, 
                     cc_param_delta = NA, cc_param_delta.s = NA, cc_param_R.s = NA, 
                     ipw_nonparam_delta = NA, ipw_nonparam_delta.s = NA, ipw_nonparam_R.s = NA, 
                     ipw_param_delta = NA, ipw_param_delta.s = NA, ipw_param_R.s = NA, 
                     smle_param_delta = NA, smle_param_delta.s = NA, smle_param_R.s = NA)
for (r in 1:1000) {
  # Generate data 
  data = gen.data(n1=n1, n0=n0) 
  
  # Define vectors for outcomes/surrogates in untreated/treated 
  s1 = data$s1
  y1 = data$y1
  s0 = data$s0
  y0 = data$y0

  ##########################################################
  #Estimates with complete data ############################
  ##########################################################
  ## Estimate R with nonparametric approach (gold standard)
  Rnonparam = Rsurrogate::R.s.estimate(sone=s1, 
                                       szero=s0, 
                                       yone = y1, 
                                       yzero = y0, 
                                       type = "robust")
  sim_res[r, c("gs_nonparam_delta", "gs_nonparam_delta.s", "gs_nonparam_R.s")] = with(Rnonparam, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (gold standard) ###
  Rparam = Rsurrogate::R.s.estimate(sone=s1, 
                                    szero=s0, 
                                    yone = y1, 
                                    yzero = y0, 
                                    type = "model")
  sim_res[r, c("gs_param_delta", "gs_param_delta.s", "gs_param_R.s")] = with(Rparam, 
                                                                             c(delta, delta.s, R.s))
  
  # Simulate non-missingness indicators ###################
  ## Under MAR, probability of missingness depends on Z (logistic regression)
  m1 = rbinom(n = n1, size = 1, prob = 1 / (1 + exp(- 0.75)))
  m0 = rbinom(n = n0, size = 1, prob = 1 / (1 + exp(- 0.10)))
  s0[m0==0] = NA ### make them missing
  s1[m1==0] = NA ### make them missing

  ##########################################################
  #Estimates with incomplete data ##########################
  ##########################################################
  ## Estimate R with nonparametric approach (complete case)
  Rnonparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                            szero = s0[m0==1], 
                                            yone = y1[m1==1], 
                                            yzero = y0[m0==1], 
                                            type = "robust")
  sim_res[r, c("cc_nonparam_delta", "cc_nonparam_delta.s", "cc_nonparam_R.s")] = with(Rnonparam_miss, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (complete case)
  Rparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                         szero = s0[m0==1], 
                                         yone = y1[m1==1], 
                                         yzero = y0[m0==1], 
                                         type = "model")
  sim_res[r, c("cc_param_delta", "cc_param_delta.s", "cc_param_R.s")] = with(Rparam_miss, 
                                                                             c(delta, delta.s, R.s))
  
  ## Calculate weights for IPW approaches
  ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
  w1 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m1, 
                                      y = y1, 
                                      z = 1),
                 type = "response")
  w0 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m0, 
                                      y = y0, 
                                      z = 0),
                 type = "response")
  
  ## Estimate R with nonparametric approach (IPW)
  Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                                szero = s0, 
                                yone = y1, 
                                yzero = y0, 
                                type = "robust", 
                                ipw = TRUE, 
                                wone = w1, 
                                wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rnonparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (IPW)
  Rparam_miss_ipw = R.s.miss(sone = s1, 
                             szero = s0, 
                             yone = y1, 
                             yzero = y0, 
                             type = "model", 
                             ipw = TRUE, 
                             wone = w1, 
                             wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with semiparametric approach (SMLE)
  Rparam_miss_smle = R.s.miss(sone = s1, 
                              szero = s0,
                              yone = y1,
                              yzero = y0, 
                              type = "model", 
                              ipw = FALSE) 
  sim_res[r, c("smle_param_delta", "smle_param_delta.s", "smle_param_R.s")] = with(Rparam_miss_smle, c(delta, delta.s, R.s))
  
  ## Save 
  sim_res |> 
    write.csv("~/Dropbox (Wake Forest University)/8 - TRAINEE RESEARCH/Anh-Missing-Surrogates/mar_Z_sim_res.csv", 
              row.names = FALSE)
}
```

#### Results

```{r, echo = FALSE, fig.width = 8, fig.height = 4, cache = FALSE}
# Make them long 
res_long = sim_res |> 
  tidyr::pivot_longer(cols = gs_nonparam_delta:smle_param_R.s, 
                      names_to = "method_quantity", values_to = "est") |> 
  dplyr::mutate(quantity = sub(pattern = ".*_", 
                               replacement = "", 
                               x = method_quantity), 
                truth = dplyr::case_when(
                  quantity == "delta" ~ 12, 
                  quantity == "delta.s" ~ 6, 
                  .default = 0.5), 
                quantity = factor(x = quantity, 
                                  levels = c("delta", "delta.s", "R.s"), 
                                  labels = c(TeX("$\\Delta$"), TeX("$\\Delta_S$"), TeX("$R_S$"))),
                method = sub(pattern = "_delta", 
                             replacement = "", 
                             x = sub(pattern = "_delta.s", 
                                     replacement = "", 
                                     x = sub(pattern = "_R.s", 
                                             replacement = "", 
                                             x = method_quantity)))) |> 
  dplyr::select(-method_quantity) |> 
  dplyr::mutate(method = factor(x = method, 
                                levels = c("gs_nonparam", "gs_param", 
                                           "cc_nonparam", "cc_param", 
                                           "ipw_nonparam", "ipw_param", 
                                           "smle_param"), 
                                labels = c("GS (NP)", "GS (P)", 
                                           "CC (NP)", "CC (P)", 
                                           "IPW (NP)", "IPW (P)",
                                           "SMLE (P)")), 
                parametric = !grepl(pattern = "(NP)", 
                                   x = method))

# Make a boxplot 
res_long |> 
  ggplot(aes(x = method, y = est, fill = parametric)) + 
  geom_boxplot() + 
  geom_hline(aes(yintercept = truth), linetype = 2, color = "white") + 
  facet_wrap(~quantity, scales = "free", ncol = 3, labeller = label_parsed) + 
  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 5)) + 
  theme_minimal() + 
  theme(legend.position = "top", 
        strip.background = element_rect(fill = "black"), 
        strip.text = element_text(color = "white")) + 
  ggtitle(label = "Boxplot of estimates under missingness at random (MAR)")
```

### Under MAR Version 3 (Missingness Depends on Above/Below Median of Y)

Alternative assumptions made at this stage: 

  4.  Some patients are missing data on the surrogate $S$ **at random**. Specifically, the probability of a patient's surrogate being missing depends on their primary outcome $Y$ (being above/below the median). 

#### One Iteration

```{r 1 sim MAR disc Y}
# Be reproducible queens 
set.seed(1)

# Set sample sizes 
n1 = 1000
n0 = 1000

# Generate data 
data = gen.data(n1 = n1, n0 = n0) 

# Define vectors for outcomes/surrogates in untreated/treated 
s1 = data$s1
y1 = data$y1
s0 = data$s0
y0 = data$y0

##########################################################
#Estimates with complete data ############################
##########################################################
## Estimate R with nonparametric approach (gold standard)
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "robust")

## Estimate R with parametric approach (gold standard) ###
Rsurrogate::R.s.estimate(sone = s1, 
                         szero = s0, 
                         yone = y1, 
                         yzero = y0, 
                         type = "model")

# Simulate non-missingness indicators ###################
## Under MAR, probability of missingness depends on whether Y was above/below median
m1 = rep(1,n1)
m1[y1 < median(y1)] = rbinom(sum(y1 < median(y1)),1,0.70)
m0 = rep(1,n0)
m0[y0 > median(y0)] = rbinom(sum(y0 > median(y0)),1,0.60)
s0[m0==0] = NA ### make them missing
s1[m1==0] = NA ### make them missing

## Summarize amount of missingness
1 - mean(c(m0, m1)) ### total (both treatment groups)
1 - mean(m1) ### treatment group
1 - mean(m0) ### control group

##########################################################
#Estimates with incomplete data ##########################
##########################################################
## Estimate R with nonparametric approach (complete case)
Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                         szero = s0[m0==1], 
                         yone = y1[m1==1], 
                         yzero = y0[m0==1], 
                         type = "robust")

## Calculate weights for IPW approaches
ipw_dat = data.frame(m = c(m1, m0), 
                     y = c(y1, y0), 
                     z = rep(x = c(1, 0), each = 1000))
ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
w1 = predict(object = ipw_fit, 
               newdata = data.frame(m = m1, 
                                    y = y1, 
                                    z = 1),
               type = "response") 
w0 = predict(object = ipw_fit, 
               newdata = data.frame(m = m0, 
                                    y = y0, 
                                    z = 0),
               type = "response") 

## Estimate R with nonparametric approach (IPW)
Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                              szero = s0, 
                              yone = y1, 
                              yzero = y0, 
                              type = "robust", 
                              ipw = TRUE, 
                              wone = w1, 
                              wzero = w0)
print(Rnonparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_ipw = R.s.miss(sone = s1, 
                           szero = s0, 
                           yone = y1, 
                           yzero = y0, 
                           type = "model", 
                           ipw = TRUE, 
                           wone = w1, 
                           wzero = w0)
print(Rparam_miss_ipw)

## Estimate R with parametric approach (model-based)
Rparam_miss_smle = R.s.miss(sone = s1, 
                            szero = s0,
                            yone = y1,
                            yzero = y0, 
                            type = "model", 
                            ipw = FALSE) 
print(Rparam_miss_smle)
```

#### 1000 Iterations 

```{r 1000 sims MAR disc Y}
# Be reproducible queens 
set.seed(1)

sim_res = data.frame(r = 1:1000, 
                     gs_nonparam_delta = NA, gs_nonparam_delta.s = NA, gs_nonparam_R.s = NA, 
                     gs_param_delta = NA, gs_param_delta.s = NA, gs_param_R.s = NA, 
                     cc_nonparam_delta = NA, cc_nonparam_delta.s = NA, cc_nonparam_R.s = NA, 
                     cc_param_delta = NA, cc_param_delta.s = NA, cc_param_R.s = NA, 
                     ipw_nonparam_delta = NA, ipw_nonparam_delta.s = NA, ipw_nonparam_R.s = NA, 
                     ipw_param_delta = NA, ipw_param_delta.s = NA, ipw_param_R.s = NA, 
                     smle_param_delta = NA, smle_param_delta.s = NA, smle_param_R.s = NA)
for (r in 1:1000) {
  # Generate data 
  data = gen.data(n1=n1, n0=n0) 
  
  # Define vectors for outcomes/surrogates in untreated/treated 
  s1 = data$s1
  y1 = data$y1
  s0 = data$s0
  y0 = data$y0

  ##########################################################
  #Estimates with complete data ############################
  ##########################################################
  ## Estimate R with nonparametric approach (gold standard)
  Rnonparam = Rsurrogate::R.s.estimate(sone=s1, 
                                       szero=s0, 
                                       yone = y1, 
                                       yzero = y0, 
                                       type = "robust")
  sim_res[r, c("gs_nonparam_delta", "gs_nonparam_delta.s", "gs_nonparam_R.s")] = with(Rnonparam, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (gold standard) ###
  Rparam = Rsurrogate::R.s.estimate(sone=s1, 
                                    szero=s0, 
                                    yone = y1, 
                                    yzero = y0, 
                                    type = "model")
  sim_res[r, c("gs_param_delta", "gs_param_delta.s", "gs_param_R.s")] = with(Rparam, 
                                                                             c(delta, delta.s, R.s))
  
  # Simulate non-missingness indicators ###################
  ## Under MAR, probability of missingness depends on whether Y was above/below median
  m1 = rep(1,n1)
  m1[y1 < median(y1)] = rbinom(sum(y1 < median(y1)),1,0.70)
  m0 = rep(1,n0)
  m0[y0 > median(y0)] = rbinom(sum(y0 > median(y0)),1,0.60)
  s0[m0==0] = NA ### make them missing
  s1[m1==0] = NA ### make them missing

  ##########################################################
  #Estimates with incomplete data ##########################
  ##########################################################
  ## Estimate R with nonparametric approach (complete case)
  Rnonparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                            szero = s0[m0==1], 
                                            yone = y1[m1==1], 
                                            yzero = y0[m0==1], 
                                            type = "robust")
  sim_res[r, c("cc_nonparam_delta", "cc_nonparam_delta.s", "cc_nonparam_R.s")] = with(Rnonparam_miss, 
                                                                                      c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (complete case)
  Rparam_miss = Rsurrogate::R.s.estimate(sone = s1[m1==1], 
                                         szero = s0[m0==1], 
                                         yone = y1[m1==1], 
                                         yzero = y0[m0==1], 
                                         type = "model")
  sim_res[r, c("cc_param_delta", "cc_param_delta.s", "cc_param_R.s")] = with(Rparam_miss, 
                                                                             c(delta, delta.s, R.s))
  
  ## Calculate weights for IPW approaches
  ipw_fit = glm(formula = m ~ y * z, 
              family = "binomial", 
              data = ipw_dat)
  w1 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m1, 
                                      y = y1, 
                                      z = 1),
                 type = "response")
  w0 = predict(object = ipw_fit, 
                 newdata = data.frame(m = m0, 
                                      y = y0, 
                                      z = 0),
                 type = "response")
  
  ## Estimate R with nonparametric approach (IPW)
  Rnonparam_miss_ipw = R.s.miss(sone = s1, 
                                szero = s0, 
                                yone = y1, 
                                yzero = y0, 
                                type = "robust", 
                                ipw = TRUE, 
                                wone = w1, 
                                wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rnonparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with parametric approach (IPW)
  Rparam_miss_ipw = R.s.miss(sone = s1, 
                             szero = s0, 
                             yone = y1, 
                             yzero = y0, 
                             type = "model", 
                             ipw = TRUE, 
                             wone = w1, 
                             wzero = w0)
  sim_res[r, c("ipw_nonparam_delta", "ipw_nonparam_delta.s", "ipw_nonparam_R.s")] = with(Rparam_miss_ipw, 
                                                                                         c(delta, delta.s, R.s))
  
  ## Estimate R with semiparametric approach (SMLE)
  Rparam_miss_smle = R.s.miss(sone = s1, 
                              szero = s0,
                              yone = y1,
                              yzero = y0, 
                              type = "model", 
                              ipw = FALSE) 
  sim_res[r, c("smle_param_delta", "smle_param_delta.s", "smle_param_R.s")] = with(Rparam_miss_smle, c(delta, delta.s, R.s))
  
  ## Save 
  sim_res |> 
    write.csv("~/Dropbox (Wake Forest University)/8 - TRAINEE RESEARCH/Anh-Missing-Surrogates/mar_discY_sim_res.csv", 
              row.names = FALSE)
}
```

#### Results

```{r, echo = FALSE, fig.width = 8, fig.height = 4, cache = FALSE}
# Make them long 
res_long = sim_res |> 
  tidyr::pivot_longer(cols = gs_nonparam_delta:smle_param_R.s, 
                      names_to = "method_quantity", values_to = "est") |> 
  dplyr::mutate(quantity = sub(pattern = ".*_", 
                               replacement = "", 
                               x = method_quantity), 
                truth = dplyr::case_when(
                  quantity == "delta" ~ 12, 
                  quantity == "delta.s" ~ 6, 
                  .default = 0.5), 
                quantity = factor(x = quantity, 
                                  levels = c("delta", "delta.s", "R.s"), 
                                  labels = c(TeX("$\\Delta$"), TeX("$\\Delta_S$"), TeX("$R_S$"))),
                method = sub(pattern = "_delta", 
                             replacement = "", 
                             x = sub(pattern = "_delta.s", 
                                     replacement = "", 
                                     x = sub(pattern = "_R.s", 
                                             replacement = "", 
                                             x = method_quantity)))) |> 
  dplyr::select(-method_quantity) |> 
  dplyr::mutate(method = factor(x = method, 
                                levels = c("gs_nonparam", "gs_param", 
                                           "cc_nonparam", "cc_param", 
                                           "ipw_nonparam", "ipw_param", 
                                           "smle_param"), 
                                labels = c("GS (NP)", "GS (P)", 
                                           "CC (NP)", "CC (P)", 
                                           "IPW (NP)", "IPW (P)",
                                           "SMLE (P)")), 
                parametric = !grepl(pattern = "(NP)", 
                                   x = method))

# Make a boxplot 
res_long |> 
  ggplot(aes(x = method, y = est, fill = parametric)) + 
  geom_boxplot() + 
  geom_hline(aes(yintercept = truth), linetype = 2, color = "white") + 
  facet_wrap(~quantity, scales = "free", ncol = 3, labeller = label_parsed) + 
  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 5)) + 
  theme_minimal() + 
  theme(legend.position = "top", 
        strip.background = element_rect(fill = "black"), 
        strip.text = element_text(color = "white")) + 
  ggtitle(label = "Boxplot of estimates under missingness at random (MAR)")
```